<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>NetworkManager.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Browser.html">Browser</a><ul class='methods'><li data-type='method'><a href="Browser.html#init">init</a></li><li data-type='method'><a href="Browser.html#getBoundingClientRect">getBoundingClientRect</a></li><li data-type='method'><a href="Browser.html#build">build</a></li><li data-type='method'><a href="Browser.html#_handleWindowPage">_handleWindowPage</a></li><li data-type='method'><a href="Browser.html#bringToFront">bringToFront</a></li><li data-type='method'><a href="Browser.html#close">close</a></li><li data-type='method'><a href="Browser.html#pages">pages</a></li><li data-type='method'><a href="Browser.html#getPageById">getPageById</a></li><li data-type='method'><a href="Browser.html#frontPage">frontPage</a></li><li data-type='method'><a href="Browser.html#newPage">newPage</a></li><li data-type='method'><a href="Browser.html#_setCtrlIcons">_setCtrlIcons</a></li><li data-type='method'><a href="Browser.html#_newPageWithoutReady">_newPageWithoutReady</a></li></ul></li><li></li><li><a href="BrowserManager.html">BrowserManager</a><ul class='methods'><li data-type='method'><a href="BrowserManager.html#launch">launch</a></li><li data-type='method'><a href="BrowserManager.html#getEarliest">getEarliest</a></li><li data-type='method'><a href="BrowserManager.html#get">get</a></li><li data-type='method'><a href="BrowserManager.html#frontBrowser">frontBrowser</a></li></ul></li><li></li><li><a href="ElementHandle.html">ElementHandle</a><ul class='methods'><li data-type='method'><a href="ElementHandle.html#$">$</a></li><li data-type='method'><a href="ElementHandle.html#$$">$$</a></li><li data-type='method'><a href="ElementHandle.html#$eval">$eval</a></li><li data-type='method'><a href="ElementHandle.html#$$eval">$$eval</a></li><li data-type='method'><a href="ElementHandle.html#$x">$x</a></li><li data-type='method'><a href="ElementHandle.html#asElement">asElement</a></li><li data-type='method'><a href="ElementHandle.html#boundingBox">boundingBox</a></li><li data-type='method'><a href="ElementHandle.html#textContent">textContent</a></li><li data-type='method'><a href="ElementHandle.html#boxModel">boxModel</a></li><li data-type='method'><a href="ElementHandle.html#click">click</a></li><li data-type='method'><a href="ElementHandle.html#show">show</a></li><li data-type='method'><a href="ElementHandle.html#hide">hide</a></li><li data-type='method'><a href="ElementHandle.html#contentFrame">contentFrame</a></li><li data-type='method'><a href="ElementHandle.html#dispose">dispose</a></li><li data-type='method'><a href="ElementHandle.html#executionContext">executionContext</a></li><li data-type='method'><a href="ElementHandle.html#check">check</a></li><li data-type='method'><a href="ElementHandle.html#uncheck">uncheck</a></li><li data-type='method'><a href="ElementHandle.html#getProperties">getProperties</a></li><li data-type='method'><a href="ElementHandle.html#getProperty">getProperty</a></li><li data-type='method'><a href="ElementHandle.html#focus">focus</a></li><li data-type='method'><a href="ElementHandle.html#blur">blur</a></li><li data-type='method'><a href="ElementHandle.html#getAttributes">getAttributes</a></li><li data-type='method'><a href="ElementHandle.html#getAttribute">getAttribute</a></li><li data-type='method'><a href="ElementHandle.html#hover">hover</a></li><li data-type='method'><a href="ElementHandle.html#isIntersectingViewport">isIntersectingViewport</a></li><li data-type='method'><a href="ElementHandle.html#jsonValue">jsonValue</a></li><li data-type='method'><a href="ElementHandle.html#press">press</a></li><li data-type='method'><a href="ElementHandle.html#screenshot">screenshot</a></li><li data-type='method'><a href="ElementHandle.html#tap">tap</a></li><li data-type='method'><a href="ElementHandle.html#toString">toString</a></li><li data-type='method'><a href="ElementHandle.html#type">type</a></li><li data-type='method'><a href="ElementHandle.html#uploadFile">uploadFile</a></li></ul></li><li></li><li><a href="EventEmitter.html">EventEmitter</a><ul class='methods'><li data-type='method'><a href="EventEmitter.html#.noConflict">noConflict</a></li></ul></li><li><a href="Frame.html">Frame</a><ul class='methods'><li data-type='method'><a href="Frame.html#addScriptTag">addScriptTag</a></li><li data-type='method'><a href="Frame.html#addStyleTag">addStyleTag</a></li><li data-type='method'><a href="Frame.html#childFrames">childFrames</a></li><li data-type='method'><a href="Frame.html#content">content</a></li><li data-type='method'><a href="Frame.html#evaluate">evaluate</a></li><li data-type='method'><a href="Frame.html#goto">goto</a></li><li data-type='method'><a href="Frame.html#isDetached">isDetached</a></li><li data-type='method'><a href="Frame.html#name">name</a></li><li data-type='method'><a href="Frame.html#page">page</a></li><li data-type='method'><a href="Frame.html#parentFrame">parentFrame</a></li><li data-type='method'><a href="Frame.html#select">select</a></li><li data-type='method'><a href="Frame.html#setContent">setContent</a></li><li data-type='method'><a href="Frame.html#title">title</a></li><li data-type='method'><a href="Frame.html#type">type</a></li><li data-type='method'><a href="Frame.html#press">press</a></li><li data-type='method'><a href="Frame.html#url">url</a></li><li data-type='method'><a href="Frame.html#waitFor">waitFor</a></li><li data-type='method'><a href="Frame.html#waitForFunction">waitForFunction</a></li><li data-type='method'><a href="Frame.html#waitForNavigation">waitForNavigation</a></li><li data-type='method'><a href="Frame.html#waitForNavigationOut">waitForNavigationOut</a></li><li data-type='method'><a href="Frame.html#waitForNavigationTo">waitForNavigationTo</a></li><li data-type='method'><a href="Frame.html#waitForSelector">waitForSelector</a></li><li data-type='method'><a href="Frame.html#hasElement">hasElement</a></li><li data-type='method'><a href="Frame.html#waitForXPath">waitForXPath</a></li><li data-type='method'><a href="Frame.html#click">click</a></li><li data-type='method'><a href="Frame.html#focus">focus</a></li><li data-type='method'><a href="Frame.html#blur">blur</a></li><li data-type='method'><a href="Frame.html#hover">hover</a></li><li data-type='method'><a href="Frame.html#tap">tap</a></li><li data-type='method'><a href="Frame.html#localStorageKeys">localStorageKeys</a></li><li data-type='method'><a href="Frame.html#localStorageGet">localStorageGet</a></li><li data-type='method'><a href="Frame.html#localStorageSet">localStorageSet</a></li><li data-type='method'><a href="Frame.html#localStorageRemove">localStorageRemove</a></li><li data-type='method'><a href="Frame.html#$">$</a></li><li data-type='method'><a href="Frame.html#$$">$$</a></li><li data-type='method'><a href="Frame.html#$eval">$eval</a></li><li data-type='method'><a href="Frame.html#$$eval">$$eval</a></li><li data-type='method'><a href="Frame.html#$x">$x</a></li></ul></li><li></li><li><a href="Page.html">Page</a><ul class='methods'><li data-type='method'><a href="Page.html#init">init</a></li><li data-type='method'><a href="Page.html#build">build</a></li><li data-type='method'><a href="Page.html#isLoading">isLoading</a></li><li data-type='method'><a href="Page.html#isLoadingMainFrame">isLoadingMainFrame</a></li><li data-type='method'><a href="Page.html#bringToFront">bringToFront</a></li><li data-type='method'><a href="Page.html#browser">browser</a></li><li data-type='method'><a href="Page.html#close">close</a></li><li data-type='method'><a href="Page.html#cookie">cookie</a></li><li data-type='method'><a href="Page.html#cookies">cookies</a></li><li data-type='method'><a href="Page.html#deleteCookies">deleteCookies</a></li><li data-type='method'><a href="Page.html#frames">frames</a></li><li data-type='method'><a href="Page.html#canGoBack">canGoBack</a></li><li data-type='method'><a href="Page.html#canGoForward">canGoForward</a></li><li data-type='method'><a href="Page.html#goBack">goBack</a></li><li data-type='method'><a href="Page.html#goForward">goForward</a></li><li data-type='method'><a href="Page.html#isClosed">isClosed</a></li><li data-type='method'><a href="Page.html#mainFrame">mainFrame</a></li><li data-type='method'><a href="Page.html#find">find</a></li><li data-type='method'><a href="Page.html#reload">reload</a></li><li data-type='method'><a href="Page.html#screenshot">screenshot</a></li><li data-type='method'><a href="Page.html#setCookie">setCookie</a></li><li data-type='method'><a href="Page.html#clearHistory">clearHistory</a></li><li data-type='method'><a href="Page.html#waitForRequest">waitForRequest</a></li><li data-type='method'><a href="Page.html#waitForResponse">waitForResponse</a></li><li data-type='method'><a href="Page.html#evaluateHandle">evaluateHandle</a></li><li data-type='method'><a href="Page.html#queryObjects">queryObjects</a></li><li data-type='method'><a href="Page.html#target">target</a></li><li data-type='method'><a href="Page.html#_initWindowProxy">_initWindowProxy</a></li><li data-type='method'><a href="Page.html#$">$</a></li><li data-type='method'><a href="Page.html#$$">$$</a></li><li data-type='method'><a href="Page.html#$eval">$eval</a></li><li data-type='method'><a href="Page.html#$$eval">$$eval</a></li><li data-type='method'><a href="Page.html#$x">$x</a></li><li data-type='method'><a href="Page.html#addScriptTag">addScriptTag</a></li><li data-type='method'><a href="Page.html#addStyleTag">addStyleTag</a></li><li data-type='method'><a href="Page.html#click">click</a></li><li data-type='method'><a href="Page.html#content">content</a></li><li data-type='method'><a href="Page.html#evaluate">evaluate</a></li><li data-type='method'><a href="Page.html#focus">focus</a></li><li data-type='method'><a href="Page.html#hover">hover</a></li><li data-type='method'><a href="Page.html#goto">goto</a></li><li data-type='method'><a href="Page.html#select">select</a></li><li data-type='method'><a href="Page.html#setContent">setContent</a></li><li data-type='method'><a href="Page.html#tap">tap</a></li><li data-type='method'><a href="Page.html#title">title</a></li><li data-type='method'><a href="Page.html#type">type</a></li><li data-type='method'><a href="Page.html#press">press</a></li><li data-type='method'><a href="Page.html#url">url</a></li><li data-type='method'><a href="Page.html#waitFor">waitFor</a></li><li data-type='method'><a href="Page.html#waitForFunction">waitForFunction</a></li><li data-type='method'><a href="Page.html#waitForNavigation">waitForNavigation</a></li><li data-type='method'><a href="Page.html#waitForNavigationOut">waitForNavigationOut</a></li><li data-type='method'><a href="Page.html#waitForNavigationTo">waitForNavigationTo</a></li><li data-type='method'><a href="Page.html#waitForSelector">waitForSelector</a></li><li data-type='method'><a href="Page.html#hasElement">hasElement</a></li><li data-type='method'><a href="Page.html#waitForXPath">waitForXPath</a></li><li data-type='method'><a href="Page.html#localStorageKeys">localStorageKeys</a></li><li data-type='method'><a href="Page.html#localStorageGet">localStorageGet</a></li><li data-type='method'><a href="Page.html#localStorageSet">localStorageSet</a></li><li data-type='method'><a href="Page.html#localStorageRemove">localStorageRemove</a></li></ul></li><li></li><li><a href="WindowPage.html">WindowPage</a><ul class='methods'><li data-type='method'><a href="WindowPage.html#init">init</a></li><li data-type='method'><a href="WindowPage.html#build">build</a></li><li data-type='method'><a href="WindowPage.html#isLoading">isLoading</a></li><li data-type='method'><a href="WindowPage.html#isLoadingMainFrame">isLoadingMainFrame</a></li><li data-type='method'><a href="WindowPage.html#bringToFront">bringToFront</a></li><li data-type='method'><a href="WindowPage.html#browser">browser</a></li><li data-type='method'><a href="WindowPage.html#close">close</a></li><li data-type='method'><a href="WindowPage.html#cookie">cookie</a></li><li data-type='method'><a href="WindowPage.html#cookies">cookies</a></li><li data-type='method'><a href="WindowPage.html#deleteCookies">deleteCookies</a></li><li data-type='method'><a href="WindowPage.html#frames">frames</a></li><li data-type='method'><a href="WindowPage.html#canGoBack">canGoBack</a></li><li data-type='method'><a href="WindowPage.html#canGoForward">canGoForward</a></li><li data-type='method'><a href="WindowPage.html#goBack">goBack</a></li><li data-type='method'><a href="WindowPage.html#goForward">goForward</a></li><li data-type='method'><a href="WindowPage.html#isClosed">isClosed</a></li><li data-type='method'><a href="WindowPage.html#mainFrame">mainFrame</a></li><li data-type='method'><a href="WindowPage.html#find">find</a></li><li data-type='method'><a href="WindowPage.html#reload">reload</a></li><li data-type='method'><a href="WindowPage.html#screenshot">screenshot</a></li><li data-type='method'><a href="WindowPage.html#setCookie">setCookie</a></li><li data-type='method'><a href="WindowPage.html#clearHistory">clearHistory</a></li><li data-type='method'><a href="WindowPage.html#waitForRequest">waitForRequest</a></li><li data-type='method'><a href="WindowPage.html#waitForResponse">waitForResponse</a></li><li data-type='method'><a href="WindowPage.html#evaluateHandle">evaluateHandle</a></li><li data-type='method'><a href="WindowPage.html#queryObjects">queryObjects</a></li><li data-type='method'><a href="WindowPage.html#target">target</a></li><li data-type='method'><a href="WindowPage.html#_initWindowProxy">_initWindowProxy</a></li><li data-type='method'><a href="WindowPage.html#$">$</a></li><li data-type='method'><a href="WindowPage.html#$$">$$</a></li><li data-type='method'><a href="WindowPage.html#$eval">$eval</a></li><li data-type='method'><a href="WindowPage.html#$$eval">$$eval</a></li><li data-type='method'><a href="WindowPage.html#$x">$x</a></li><li data-type='method'><a href="WindowPage.html#addScriptTag">addScriptTag</a></li><li data-type='method'><a href="WindowPage.html#addStyleTag">addStyleTag</a></li><li data-type='method'><a href="WindowPage.html#click">click</a></li><li data-type='method'><a href="WindowPage.html#content">content</a></li><li data-type='method'><a href="WindowPage.html#evaluate">evaluate</a></li><li data-type='method'><a href="WindowPage.html#focus">focus</a></li><li data-type='method'><a href="WindowPage.html#hover">hover</a></li><li data-type='method'><a href="WindowPage.html#goto">goto</a></li><li data-type='method'><a href="WindowPage.html#select">select</a></li><li data-type='method'><a href="WindowPage.html#setContent">setContent</a></li><li data-type='method'><a href="WindowPage.html#tap">tap</a></li><li data-type='method'><a href="WindowPage.html#title">title</a></li><li data-type='method'><a href="WindowPage.html#type">type</a></li><li data-type='method'><a href="WindowPage.html#press">press</a></li><li data-type='method'><a href="WindowPage.html#url">url</a></li><li data-type='method'><a href="WindowPage.html#waitFor">waitFor</a></li><li data-type='method'><a href="WindowPage.html#waitForFunction">waitForFunction</a></li><li data-type='method'><a href="WindowPage.html#waitForNavigation">waitForNavigation</a></li><li data-type='method'><a href="WindowPage.html#waitForNavigationOut">waitForNavigationOut</a></li><li data-type='method'><a href="WindowPage.html#waitForNavigationTo">waitForNavigationTo</a></li><li data-type='method'><a href="WindowPage.html#waitForSelector">waitForSelector</a></li><li data-type='method'><a href="WindowPage.html#hasElement">hasElement</a></li><li data-type='method'><a href="WindowPage.html#waitForXPath">waitForXPath</a></li><li data-type='method'><a href="WindowPage.html#localStorageKeys">localStorageKeys</a></li><li data-type='method'><a href="WindowPage.html#localStorageGet">localStorageGet</a></li><li data-type='method'><a href="WindowPage.html#localStorageSet">localStorageSet</a></li><li data-type='method'><a href="WindowPage.html#localStorageRemove">localStorageRemove</a></li></ul></li><li><a href="Target.html">Target</a><ul class='methods'><li data-type='method'><a href="Target.html#browser">browser</a></li><li data-type='method'><a href="Target.html#opener">opener</a></li><li data-type='method'><a href="Target.html#page">page</a></li><li data-type='method'><a href="Target.html#type">type</a></li><li data-type='method'><a href="Target.html#url">url</a></li></ul></li><li></li><li><a href="Ipc.html">Ipc</a><ul class='methods'><li data-type='method'><a href="Ipc.html#send">send</a></li><li data-type='method'><a href="Ipc.html#sendOn">sendOn</a></li><li data-type='method'><a href="Ipc.html#on">on</a></li><li data-type='method'><a href="Ipc.html#once">once</a></li><li data-type='method'><a href="Ipc.html#off">off</a></li><li data-type='method'><a href="Ipc.html#dispatch">dispatch</a></li></ul></li><li></li><li><a href="BoundIpc.html">BoundIpc</a><ul class='methods'><li data-type='method'><a href="BoundIpc.html#send">send</a></li><li data-type='method'><a href="BoundIpc.html#sendOn">sendOn</a></li><li data-type='method'><a href="BoundIpc.html#on">on</a></li><li data-type='method'><a href="BoundIpc.html#once">once</a></li><li data-type='method'><a href="BoundIpc.html#off">off</a></li><li data-type='method'><a href="BoundIpc.html#dispatch">dispatch</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="Browser.html#event:back">back</a></li><li><a href="Browser.html#event:front">front</a></li><li><a href="Browser.html#event:close">close</a></li><li><a href="Browser.html#event:new-page">new-page</a></li><li><a href="Browser.html#event:targetcreated">targetcreated</a></li><li><a href="Browser.html#event:targetchanged">targetchanged</a></li><li><a href="Browser.html#event:targetdestroyed">targetdestroyed</a></li><li><a href="Page.html#event:dom-event">dom-event</a></li><li><a href="Page.html#event:frameattached">frameattached</a></li><li><a href="Page.html#event:framenavigated">framenavigated</a></li><li><a href="Page.html#event:connect">connect</a></li><li><a href="Page.html#event:framedetached">framedetached</a></li><li><a href="Page.html#event:disconnect">disconnect</a></li><li><a href="Page.html#event:load-start">load-start</a></li><li><a href="Page.html#event:load-fail">load-fail</a></li><li><a href="Page.html#event:load-end">load-end</a></li><li><a href="Page.html#event:title-updated">title-updated</a></li><li><a href="Page.html#event:favicon-updated">favicon-updated</a></li><li><a href="Page.html#event:console">console</a></li><li><a href="Page.html#event:new-window">new-window</a></li><li><a href="Page.html#event:will-navigate">will-navigate</a></li><li><a href="Page.html#event:dom-ready">dom-ready</a></li><li><a href="Page.html#event:load">load</a></li><li><a href="Page.html#event:domcontentloaded">domcontentloaded</a></li><li><a href="Page.html#event:historyNavigation">historyNavigation</a></li><li><a href="Page.html#event:hashchange">hashchange</a></li><li></li><li><a href="Page.html#event:back">back</a></li><li><a href="Page.html#event:front">front</a></li><li><a href="Page.html#event:close">close</a></li><li><a href="WindowPage.html#event:dom-event">dom-event</a></li><li><a href="WindowPage.html#event:frameattached">frameattached</a></li><li><a href="WindowPage.html#event:framenavigated">framenavigated</a></li><li><a href="WindowPage.html#event:connect">connect</a></li><li><a href="WindowPage.html#event:framedetached">framedetached</a></li><li><a href="WindowPage.html#event:disconnect">disconnect</a></li><li><a href="WindowPage.html#event:load-start">load-start</a></li><li><a href="WindowPage.html#event:load-fail">load-fail</a></li><li><a href="WindowPage.html#event:load-end">load-end</a></li><li><a href="WindowPage.html#event:title-updated">title-updated</a></li><li><a href="WindowPage.html#event:favicon-updated">favicon-updated</a></li><li><a href="WindowPage.html#event:console">console</a></li><li><a href="WindowPage.html#event:new-window">new-window</a></li><li><a href="WindowPage.html#event:will-navigate">will-navigate</a></li><li><a href="WindowPage.html#event:dom-ready">dom-ready</a></li><li><a href="WindowPage.html#event:load">load</a></li><li><a href="WindowPage.html#event:domcontentloaded">domcontentloaded</a></li><li><a href="WindowPage.html#event:historyNavigation">historyNavigation</a></li><li><a href="WindowPage.html#event:hashchange">hashchange</a></li><li><a href="WindowPage.html#event:back">back</a></li><li><a href="WindowPage.html#event:front">front</a></li><li><a href="WindowPage.html#event:close">close</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_onRequestPaused">_onRequestPaused</a></li><li><a href="global.html#_onRequest">_onRequest</a></li><li><a href="global.html#_onRequestServedFromCache">_onRequestServedFromCache</a></li><li><a href="global.html#setCacheEnabled">setCacheEnabled</a></li><li><a href="global.html#setRequestInterception">setRequestInterception</a></li><li><a href="global.html#headersArray">headersArray</a></li><li><a href="global.html#urlMatch">urlMatch</a></li><li><a href="global.html#reqUpdater">reqUpdater</a></li><li><a href="global.html#resUpdater">resUpdater</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">NetworkManager.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import EventEmitter from "./EventEmitter.js"
const {remote} = require("electron")

export default class NetworkManager extends EventEmitter {
  constructor() {
    super()

    this._userCacheDisabled = false
    this._userRequestInterceptionEnabled = false
    this._protocolRequestInterceptionEnabled = false

    /** @type {!Map&lt;string, !Request>} */
    this._requestIdToRequest = new Map()
    /** @type {!Map&lt;string, !Protocol.Network.requestWillBeSentPayload>} */
    this._requestIdToRequestWillBeSentEvent = new Map()
    /** @type {!Map&lt;string, string>} */
    this._requestIdToInterceptionId = new Map()
  }
  start(webContentsId) {
    let contents = remote.webContents.fromId(webContentsId)
    if (!contents) {
      return
    }
    this._webContents = contents
    this._client = this._webContents.debugger
    if (!this._client.isAttached()) {
      this._client.attach("1.1")
    }

    this._client.on("message", (_, method, params) => {
      try {
        switch (method) {
          case "Fetch.requestPaused":
            this._onRequestPaused(params)
            break
          case "Network.requestWillBeSent":
            this._onRequestWillBeSent(params)
            break
          case "Network.responseReceived":
            this._onResponseReceived(params)
            break
          case "Network.requestServedFromCache":
            this._onRequestServedFromCache(params)
            break
          case "Network.loadingFinished":
            this._onLoadingFinished(params)
            break
          case "Network.loadingFailed":
            this._onLoadingFailed(params)
            break
        }
      } catch (e) {
        console.error("NetworkManager error:", e)
      }
    })

    this._client.sendCommand("Network.enable")
  }
  _onRequestWillBeSent(params) {
    // Request interception doesn't happen for data URLs with Network Service.
    if (
      this._protocolRequestInterceptionEnabled &amp;&amp;
      !params.request.url.startsWith("data:")
    ) {
      const requestId = params.requestId
      const interceptionId = this._requestIdToInterceptionId.get(requestId)
      if (interceptionId) {
        this._onRequest(params, interceptionId)
        this._requestIdToInterceptionId.delete(requestId)
      } else {
        this._requestIdToRequestWillBeSentEvent.set(params.requestId, params)
      }
      return
    }
    this._onRequest(params, null)
  }
  /**
   * @param {!Protocol.Fetch.requestPausedPayload} params
   */
  _onRequestPaused(params) {
    if (
      !this._userRequestInterceptionEnabled &amp;&amp;
      this._protocolRequestInterceptionEnabled
    ) {
      this._client
        .send("Fetch.continueRequest", {
          requestId: params.requestId,
        })
        .catch((err) => {
          console.error("NetworkManager.continueRequest error:", err)
        })
    }

    const requestId = params.networkId
    const interceptionId = params.requestId
    if (requestId &amp;&amp; this._requestIdToRequestWillBeSentEvent.has(requestId)) {
      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(
        requestId
      )
      this._onRequest(requestWillBeSentEvent, interceptionId)
      this._requestIdToRequestWillBeSentEvent.delete(requestId)
    } else {
      this._requestIdToInterceptionId.set(requestId, interceptionId)
    }
  }
  /**
   * @param {!Protocol.Network.requestWillBeSentPayload} params
   * @param {?string} interceptionId
   */
  _onRequest(params, interceptionId) {
    let redirectChain = []
    if (params.redirectResponse) {
      const request = this._requestIdToRequest.get(params.requestId)
      if (request) {
        this._handleRequestRedirect(request, params.redirectResponse)
        redirectChain = request._redirectChain
      }
    }

    const request = new Request(
      this._client,
      interceptionId,
      this._userRequestInterceptionEnabled,
      params,
      redirectChain
    )
    this._requestIdToRequest.set(params.requestId, request)
    this.emit("request", request)
  }
  /**
   * @param {!Protocol.Network.requestServedFromCachePayload} event
   */
  _onRequestServedFromCache(event) {
    const request = this._requestIdToRequest.get(event.requestId)
    if (request) {
      request._fromMemoryCache = true
    }
  }
  _handleRequestRedirect(request, responsePayload) {
    const response = new Response(this._client, request, responsePayload)
    request._response = response
    request._redirectChain.push(request)
    response._bodyLoadedPromiseFulfill.call(
      null,
      new Error("Response body is unavailable for redirect responses")
    )
    this._requestIdToRequest.delete(request._requestId)
    this.emit("response", response)
    this.emit("requestfinished", request)
  }
  _onResponseReceived(params) {
    const request = this._requestIdToRequest.get(params.requestId)
    if (!request) {
      return
    }

    const response = new Response(this._client, request, params.response)
    request._response = response

    this.emit("response", response)
  }
  _onLoadingFinished(params) {
    const request = this._requestIdToRequest.get(params.requestId)
    if (!request) {
      return
    }
    if (request.response()) {
      request.response()._bodyLoadedPromiseFulfill.call(null)
    }
    this._requestIdToRequest.delete(request._requestId)
    this.emit("requestfinished", request)
  }
  _onLoadingFailed(params) {
    const request = this._requestIdToRequest.get(params.requestId)
    if (!request) {
      return
    }
    request._failureText = params.errorText
    const response = request.response()
    if (response) {
      response._bodyLoadedPromiseFulfill.call(null)
    }

    this._requestIdToRequest.delete(request._requestId)
    this.emit("requestfailed", request)
  }
  /**
   * @param {boolean} enabled
   */
  async setCacheEnabled(enabled) {
    this._userCacheDisabled = !enabled
    await this._updateProtocolCacheDisabled()
  }
  /**
   * @param {boolean} value
   */
  async setRequestInterception(value) {
    this._userRequestInterceptionEnabled = value
    await this._updateProtocolRequestInterception()
  }
  async _updateProtocolRequestInterception() {
    const enabled = this._userRequestInterceptionEnabled
    if (enabled === this._protocolRequestInterceptionEnabled) {
      return
    }
    this._protocolRequestInterceptionEnabled = enabled
    if (enabled) {
      await Promise.all([
        this._updateProtocolCacheDisabled(),
        this._client.send("Fetch.enable", {
          handleAuthRequests: true,
          patterns: [{urlPattern: "*"}],
        }),
      ])
    } else {
      await Promise.all([
        this._updateProtocolCacheDisabled(),
        this._client.send("Fetch.disable"),
      ])
    }
  }
  async _updateProtocolCacheDisabled() {
    await this._client.send("Network.setCacheDisabled", {
      cacheDisabled:
        this._userCacheDisabled || this._protocolRequestInterceptionEnabled,
    })
  }
}

export class Request {
  constructor(
    client,
    interceptionId,
    allowInterception,
    params,
    redirectChain
  ) {
    this._client = client
    this._requestId = params.requestId
    this._isNavigationRequest =
      params.requestId === params.loaderId &amp;&amp; params.type === "Document"
    this._interceptionId = interceptionId
    this._allowInterception = allowInterception
    this._interceptionHandled = false
    this._response = null
    this._failureText = null

    this._url = params.request.url
    this._resourceType = params.type.toLowerCase()
    this._method = params.request.method
    this._postData = params.request.postData
    this._headers = {}
    this._redirectChain = redirectChain
    for (const key of Object.keys(params.request.headers)) {
      this._headers[key.toLowerCase()] = params.request.headers[key]
    }

    this._fromMemoryCache = false
  }
  /**
   * @return {string}
   */
  url() {
    return this._url
  }

  /**
   * @return {string}
   */
  resourceType() {
    return this._resourceType
  }

  /**
   * @return {string}
   */
  method() {
    return this._method
  }

  /**
   * @return {string|undefined}
   */
  postData() {
    return this._postData
  }

  /**
   * @return {!Object}
   */
  headers() {
    return this._headers
  }

  /**
   * @return {?Response}
   */
  response() {
    return this._response
  }

  /**
   * @return {boolean}
   */
  isNavigationRequest() {
    return this._isNavigationRequest
  }

  /**
   * @return {!Array&lt;!Request>}
   */
  redirectChain() {
    return this._redirectChain.slice()
  }

  /**
   * @return {?{errorText: string}}
   */
  failure() {
    if (!this._failureText) {
      return null
    }

    return {
      errorText: this._failureText,
    }
  }

  /**
   * @param {!Object} overrides
   * @param {?string} overrides.url
   * @param {?string} overrides.method
   * @param {?string} overrides.postData
   * @param {?Object} overrides.headers
   */
  async continue(overrides = {}) {
    // Request interception is not supported for data: urls.
    if (this._url.startsWith("data:")) {
      return
    }
    if (!this._allowInterception) {
      throw new Error("Request Interception is not enabled!")
    }
    if (!!this._interceptionHandled) {
      throw new Error("Request is already handled!")
    }
    const {url, method, postData, headers} = overrides
    this._interceptionHandled = true
    await this._client
      .send("Fetch.continueRequest", {
        requestId: this._interceptionId,
        url,
        method,
        postData,
        headers: headers ? headersArray(headers) : undefined,
      })
      .catch((error) => {
        console.error("Request.continue error: ", error)
      })
  }

  /**
   * @param {!{status: number, headers: Object, contentType: string, body: (string|Buffer)}} response
   */
  async respond(response) {
    // Mocking responses for dataURL requests is not currently supported.
    if (this._url.startsWith("data:")) {
      return
    }
    if (!this._allowInterception) {
      throw new Error("Request Interception is not enabled!")
    }
    if (!!this._interceptionHandled) {
      throw new Error("Request is already handled!")
    }
    this._interceptionHandled = true

    const responseBody =
      response.body &amp;&amp; typeof response.body === "string"
        ? Buffer.from(/** @type {string} */ (response.body))
        : /** @type {?Buffer} */ (response.body || null)

    /** @type {!Object&lt;string, string>} */
    const responseHeaders = {}
    if (response.headers) {
      for (const header of Object.keys(response.headers)) {
        responseHeaders[header.toLowerCase()] = response.headers[header]
      }
    }
    if (response.contentType) {
      responseHeaders["content-type"] = response.contentType
    }
    if (responseBody &amp;&amp; !("content-length" in responseHeaders)) {
      responseHeaders["content-length"] = String(
        Buffer.byteLength(responseBody)
      )
    }

    await this._client
      .send("Fetch.fulfillRequest", {
        requestId: this._interceptionId,
        responseCode: response.status || 200,
        responsePhrase: STATUS_TEXTS[response.status || 200],
        responseHeaders: headersArray(responseHeaders),
        body: responseBody ? responseBody.toString("base64") : undefined,
      })
      .catch((error) => {
        console.error("Request.respond error:", error)
      })
  }

  /**
   * @param {string=} errorCode
   */
  async abort(errorCode = "failed") {
    // Request interception is not supported for data: urls.
    if (this._url.startsWith("data:")) {
      return
    }
    const errorReason = errorReasons[errorCode]
    if (!errorReason) {
      throw new Error("Unknown error code: " + errorCode)
    }
    if (!this._allowInterception) {
      throw new Error("Request Interception is not enabled!")
    }
    if (!!this._interceptionHandled) {
      throw new Error("Request is already handled!")
    }
    this._interceptionHandled = true
    await this._client
      .send("Fetch.failRequest", {
        requestId: this._interceptionId,
        errorReason,
      })
      .catch((error) => {
        console.error("Request.abort error: ", error)
      })
  }
}

export class Response {
  constructor(client, request, responsePayload) {
    this._client = client
    this._request = request
    this._contentPromise = null

    this._bodyLoadedPromise = new Promise((fulfill) => {
      this._bodyLoadedPromiseFulfill = fulfill
    })

    this._remoteAddress = {
      ip: responsePayload.remoteIPAddress,
      port: responsePayload.remotePort,
    }
    this._status = responsePayload.status
    this._statusText = responsePayload.statusText
    this._url = request.url()
    this._fromDiskCache = !!responsePayload.fromDiskCache
    this._fromServiceWorker = !!responsePayload.fromServiceWorker
    this._headers = {}
    for (const key of Object.keys(responsePayload.headers)) {
      this._headers[key.toLowerCase()] = responsePayload.headers[key]
    }
  }

  /**
   * @return {{ip: string, port: number}}
   */
  remoteAddress() {
    return this._remoteAddress
  }

  /**
   * @return {string}
   */
  url() {
    return this._url
  }

  /**
   * @return {boolean}
   */
  ok() {
    return this._status === 0 || (this._status >= 200 &amp;&amp; this._status &lt;= 299)
  }

  /**
   * @return {number}
   */
  status() {
    return this._status
  }

  /**
   * @return {string}
   */
  statusText() {
    return this._statusText
  }

  /**
   * @return {!Object}
   */
  headers() {
    return this._headers
  }

  /**
   * @return {!Promise&lt;!Buffer>}
   */
  buffer() {
    if (!this._contentPromise) {
      this._contentPromise = this._bodyLoadedPromise.then(async (error) => {
        if (error) throw error
        const response = await this._client.sendCommand(
          "Network.getResponseBody",
          {
            requestId: this._request._requestId,
          }
        )
        return Buffer.from(
          response.body,
          response.base64Encoded ? "base64" : "utf8"
        )
      })
    }
    return this._contentPromise
  }

  /**
   * @return {!Promise&lt;string>}
   */
  async text() {
    const content = await this.buffer()
    return content.toString("utf8")
  }

  /**
   * @return {!Promise&lt;!Object>}
   */
  async json() {
    const content = await this.text()
    return JSON.parse(content)
  }

  /**
   * @return {!Request}
   */
  request() {
    return this._request
  }

  /**
   * @return {boolean}
   */
  fromCache() {
    return this._fromDiskCache || this._request._fromMemoryCache
  }
  /**
   * @return {boolean}
   */
  fromServiceWorker() {
    return this._fromServiceWorker
  }
}

/**
 * @param {Object&lt;string, string>} headers
 * @return {!Array&lt;{name: string, value: string}>}
 */
function headersArray(headers) {
  const result = []
  for (const name in headers) {
    result.push({name, value: headers[name] + ""})
  }

  return result
}

// List taken from https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml with extra 306 and 418 codes.
const STATUS_TEXTS = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "Switch Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "510": "Not Extended",
  "511": "Network Authentication Required",
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Fri Nov 20 2020 12:04:49 GMT+0800 (GMT+08:00) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
